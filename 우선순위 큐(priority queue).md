10장 우선순위 큐(Priority Queue)
============================

### <스택, 큐, 우선순위 큐 비교>
>스택 : 가장 나중에 들어온 데이터를 삭제 (FILO: First in Last out)   
>
>큐 : 가장 먼저 들어온 데이터를 삭제 (FIFO: First in First out)  
> 
>우선순위 큐: 가장 우선순위가 높은 데이터를 삭제
<br/>

### <우선순위 큐의 ADT>
#### 데이터: 우선순위를 가진 요소들의 모음
#### 연산
>1. init() : 우선순위 큐를 초기화
>2. insert(item) : 우선순위 큐에 항목 item을 추가
>3. delete() : 가장 우선순위가 높은 요소를 삭제하고 반환
>4. find() : 가장 우선순위가 높은 요소를 삭제하지 않고 반환
>5. is_empty() : 우선순위 큐가 공백인지 검사
>6. is_full() : 우선순위 큐가 포화인지 검사
<br/>

### <우선순위 큐의 구현 방법>
#### 1. 정렬되지 않은 배열을 사용
>삽입 : 기존의 요소들을 맨 끝에 붙이기만 하면 된다 **시간복잡도 O(1)**   
>
>삭제 : 배열이 정렬되어 있지 않으므로 처음부터 끝까지 스캔하며 가장 우선순위가 높은 요소를 찾아야한다 **시간복잡도 O(n)**  
<br/>

#### 2. 정렬된 배열을 사용
>삽입 : 정렬된 상태로 삽입해야 하기 때문에 삽입 위치를 찾아 삽입하고 뒤의 것들을 움직여야 한다 **시간복잡도 O(n)**  
>
>삭제 : 이미 정렬이 되어 있으므로 우선 순위가 가장 높은 요소를 바로 삭제한다 **시간복잡도 O(1)**  
<br/>

#### 3. 정렬되지 않은 연결 리스트(Linked List) 사용
>삽입 : 첫 번째 노드로 삽입하는 방식을 사용, 배열과 달리 노드들의 이동은 필요 없다 **시간복잡도 O(1)**  
>
>삭제 : 포인터를 따라 모든 노드를 방문하고 가장 우선순위가 높은 노드를 찾아야 한다 **시간복잡도 O(n)**  
<br/>


#### 4. 정렬된 연결 리스트(Linked List) 사용
>삽입 : 우선순위가 가장 높은 요소를 첫 번째 노드로 잡고 우선순위에 맞게 링크를 바꾸며 삽입한다 **시간복잡도 O(n)**  
>
>삭제 : 우선순위가 가장 높은 요소가 바로 첫 번째 노드이니 바로 삭제 가능하다 **시간복잡도 O(1)**  
<br/>

#### 5. 힙(heap)을 사용
>삽입 : 힙은 일종의 반 정렬 상태이므로  **시간복잡도 O(log n)**  
>
>삭제 : 힙은 일종의 반 정렬 상태이므로 **시간복잡도 O(log n)**  
<br/>

### <힙(heap)>











